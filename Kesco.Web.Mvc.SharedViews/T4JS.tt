<#
/*

T4JS 1.0

*/
#>
<#@ template language="C#v3.5" debug="true" hostspecific="true" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#PrepareDataToRender(this); #>
<#var manager = Manager.Create(Host, GenerationEnvironment); #>// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

// Make sure the compiler doesn't complain about missing Xml comments
#pragma warning disable 1591
using System;

namespace <#=AttributeNamespace#>
{
    public sealed class AjaxEndpointAttribute : Attribute
    {
		public AjaxEndpointAttribute(){}

		public AjaxEndpointAttribute(params string[] requestParameters){}
    }
}
#pragma warning restore 1591

<#manager.StartNewFile(Path.GetFileName(ScriptFileName)); #>
(function(namespace){
	var fn = window,
		  spaces = namespace.split("."),
		  ns, 
		  index,
		  segmentLength;
		
	for (index = 0, segmentLength = spaces.length; index < segmentLength; index++) {
		ns = spaces[index];
		if (typeof fn[ns] === "undefined") {
			fn[ns] = {};
		}
		
		fn = fn[ns];
	}
	
	fn.endpoint = {
		query: function(endpoint, parameters){
			var url = "";
				
			if(parameters){
				if(this._isArray(parameters)){
					url += this.buildArray(endpoint, parameters);
				}
				else if(this._isObject(parameters)){
					url += this.buildObject(parameters);
				}
				else{
					url += this.buildValue(endpoint, parameters);
				}
			}
			
			return url ? endpoint.url + "?" + url : endpoint.url;
		},
		
		buildArray: function(endpoint, parameters){
			var url = "", i;
			
			if(!endpoint.query.length){
				return url;
			}
			
			for(i = 0; i < parameters.length; i++){
				url += endpoint.query[i] + "=" + parameters[i];
						
				if(i < parameters.length - 1){
					url += "&";
				}
			}
			return url;
		},
		buildObject: function(parameters){
			var url = "", param;

			for(param in parameters){
				if(parameters.hasOwnProperty(param)){
					url += param + "=" + parameters[param] + "&";
				}
			}
			
			url = url.substring(0, url.length - 1);
			return url;
		},
		buildValue: function(endpoint, parameters){		
			return endpoint.query.length ? endpoint.query[0] + "=" + parameters : "";
		},
		
		_isNumeric:function(val) {
			return typeof val === "number" && isFinite(val);
		},
		_isFunction: function(val) {
			return typeof val === "function";
		},
		_isArray: function(val) {
			return val ? this._isNumeric(val.length) && this._isFunction(val.splice) : false;
		},
		_isObject: function(val){
			return typeof val === 'object';
		},
	
		Url: function(url, method, query){
			return {
					build: function(param){
						return <#=JavaScriptNamespace#>.endpoint.query({url: this.uri, method: this.method, query: this.query}, param);
					},
					uri: url,
					method: method,
					query: query
			};
		}
	};
	
}("<#=JavaScriptNamespace#>"));



<#=JavaScriptNamespace#>.<#=JavaScriptEndpointObject#> = (function(prefix){
	return {
<#var areasExist = false;
var areas = Areas.Where(a => !string.IsNullOrEmpty(a.Name));
for(var a = 0; a < areas.Count(); a++) {
	var area = areas.Skip(a).First();#>
		<#=area.Name.ToLower()#>: {
		<#var areaControllers = area.GetControllers().Where(c => c.ActionMethods.Any());

		for(var i = 0; i < areaControllers.Count(); i++){
		areasExist = true;
		var controller = areaControllers.Skip(i).First();#>

		<#=controller.Name.ToLower()#>: {
			<#var actions = controller.ActionMethods;
			for(var j = 0; j < actions.Count(); j++){
				var action = actions.Skip(j).First();
				var parameterNames = action.Parameters.Select(p => p.RouteNameExpression).ToArray();
				var parameterArray = string.Join(",", parameterNames);
				var url = (area.Name + "/" + controller.Name + "/" + action.Name).ToLower();
				var type = string.Join(" ", action.Parameters.Select(p => p.Type).ToArray());
				var nameSuffix = actions.Count(act => act.Name == action.Name) > 1 ? "_" + action.Verb.ToLower() : "";
			#>

				"<#=action.Name.ToLower()#><#=nameSuffix#>": new <#=JavaScriptNamespace#>.endpoint.Url(
						 prefix + "<#=url#>",
						"<#=action.Verb#>",
						[<#=parameterArray#>])<#if(j < actions.Count() - 1){#>,<#}#>
		<#} #>

			}<#if((i < areaControllers.Count() - 1)){#>,<#}#>

	<#} #>

		}<#if((a < areas.Count() - 1) || areasExist){#>,<#}#>
<#} #>



<#var controllers = DefaultArea.GetControllers().Where(c => c.ActionMethods.Any());
for(var i = 0; i < controllers.Count(); i++){
	var controller = controllers.Skip(i).First();#>
		<#=controller.Name.ToLower()#>: {
		<#var actions = controller.ActionMethods;
		for(var j = 0; j < actions.Count(); j++){
			var action = actions.Skip(j).First();
			var parameterNames = action.Parameters.Select(p => p.RouteNameExpression).ToArray();
			var parameterArray = string.Join(",", parameterNames);
			var url = (controller.Name + "/" + action.Name).ToLower();
			var type = string.Join(" ", action.Parameters.Select(p => p.Type).ToArray());
			var nameSuffix = actions.Count(act => act.Name == action.Name) > 1 ? "_" + action.Verb.ToLower() : "";
		#>

			"<#=action.Name.ToLower()#><#=nameSuffix#>": new <#=JavaScriptNamespace#>.endpoint.Url(
					prefix + "<#=url#>",
					"<#=action.Verb#>",
					[<#=parameterArray#>])<#if(j < actions.Count() - 1){#>,<#}#>
	<#} #>

		}<#if(i < controllers.Count() - 1){#>,<#}#>
	
<#} #>
	}	
}("<#=RoutePrefix#>"));


<#manager.EndBlock(); #>

<#if(GenerateReadme){
manager.StartNewFile(Path.GetFileName("README.txt")); #>
Read the full T4JS documentation at http://t4js.codeplex.com/


Set the GenerateReadme setting to false to stop generating this file


======== Getting Started ========

* Start by editing the settings found in T4JS.tt.settings.t4
* Decorate the action methods you want to generate script objects and URLs for with the AjaxEndpoint attribute
* Run the T4JS Template
* Add the output JavaScript file to your views
* You're all set to start writing beautiful JavaScript


======== URL Building ========

<script type="text/javascript">
	// Example JavaScript
	
	// Build with no parameters

	// This will be the namespace you configure in the settings file, not necessarily "app.net".
	var url = app.net.endpoints.home.index.build();
	console.log(url);


	// Build with a single parameter
	url = app.net.endpoints.home.index.build(99);
	console.log(url);

	// Build with a multiple parameters
	url = app.net.endpoints.home.index.build([99, "test", "hello"]);
	console.log(url);

	// Build with a custom query string definition
	url = app.net.endpoints.home.index.build({something: 99, somethingElse: 88});
	console.log(url); 
</script>
<#manager.EndBlock(); #>
<#}#>


<#manager.StartFooter(); #>
<#manager.EndBlock(); #>
<#manager.Process(true); #>

<#manager.RelocateScriptFile(ScriptFileName);#>


<#@ Include File="T4JS.tt.settings.t4" #>

<#+ 

const string ControllerSuffix = "Controller";

static DTE Dte;
static Project Project;
static HashSet<AreaInfo> Areas;
static AreaInfo DefaultArea;
static TextTransformation TT;
static string T4FileName;
static string T4Folder;
static Microsoft.CSharp.CSharpCodeProvider codeProvider = new Microsoft.CSharp.CSharpCodeProvider();

IEnumerable<ControllerInfo> GetControllers() {
    var controllers = new List<ControllerInfo>();

    foreach (var area in Areas) {
        controllers.AddRange(area.GetControllers());
    }

    return controllers;
}

void PrepareDataToRender(TextTransformation tt) {
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);
    Areas = new HashSet<AreaInfo>();
    //ResultTypes = new Dictionary<string, ResultTypeInfo>();

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) {
        throw new Exception("T4MVC can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);

    if (Project == null) {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }

    ProcessAreas(Project);
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    return projectItem.ContainingProject;
}

void ProcessAreas(Project project) {
    // Process the default area
    ProcessArea(project.ProjectItems, null);

    // Get the Areas folder
    ProjectItem areaProjectItem = GetProjectItem(project, AreasFolder);
    if (areaProjectItem == null)
        return;

    foreach (ProjectItem item in areaProjectItem.ProjectItems) {
        if (IsFolder(item)) {
            ProcessArea(item.ProjectItems, item.Name);
        }
    }
}

void ProcessArea(ProjectItems areaFolderItems, string name) {
    var area = new AreaInfo() { Name = name };
    ProcessAreaControllers(areaFolderItems, area);

    Areas.Add(area);

    if (String.IsNullOrEmpty(name))
        DefaultArea = area;
}

void ProcessAreaControllers(ProjectItems areaFolderItems, AreaInfo area) {
    // Get area Controllers folder
    ProjectItem controllerProjectItem = GetProjectItem(areaFolderItems, ControllersFolder);
    if (controllerProjectItem == null)
        return;

    ProcessControllersRecursive(controllerProjectItem, area);
}

void ProcessControllersRecursive(ProjectItem projectItem, AreaInfo area) {

    // Recurse into all the sub-items (both files and folder can have some - e.g. .tt files)
    foreach (ProjectItem item in projectItem.ProjectItems) {
        ProcessControllersRecursive(item, area);
    }

    if (projectItem.FileCodeModel != null) {
        DateTime controllerLastWriteTime = File.GetLastWriteTime(projectItem.get_FileNames(0));
        foreach (var type in projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>()) {
            ProcessControllerType(type, area, controllerLastWriteTime);
        }
        // Process all the elements that are namespaces
        foreach (var ns in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>()) {
            foreach (var type in ns.Members.OfType<CodeClass2>()) {
                ProcessControllerType(type, area, controllerLastWriteTime);
            }
        }
    }
}

void ProcessControllerType(CodeClass2 type, AreaInfo area, DateTime controllerLastWriteTime) {
    // Only process types that end with Controller
    // REVIEW: this check is not super reliable. Should look at base class.
    if (!type.Name.EndsWith(ControllerSuffix, StringComparison.OrdinalIgnoreCase))
        return;

    // Don't process generic classes (their concrete derived classes will be processed)
    if (type.IsGeneric)
        return;

    // Collect misc info about the controller class and add it to the collection
    var controllerInfo = new ControllerInfo {
        Area = area,
        Namespace = type.Namespace != null ? type.Namespace.Name : String.Empty,
        ClassName = type.Name
    };

    // Check if the controller has changed since the generated file was last created
    DateTime lastGenerationTime = File.GetLastWriteTime(controllerInfo.GeneratedFileFullPath);
    if (lastGenerationTime > controllerLastWriteTime) {
        controllerInfo.GeneratedCodeIsUpToDate = true;
    }

    // Either process new ControllerInfo or integrate results into existing object for partially defined controllers
    var target = area.Controllers.Add(controllerInfo) ? controllerInfo : area.Controllers.First(c => c.Equals(controllerInfo));
    
    if (type.IsAbstract) {
        // If it's abstract, set a flag and don't process action methods (derived classes will)
        target.IsAbstract = true;
    }
    else {
        // Process all the action methods in the controller
        ProcessControllerActionMethods(target, type);
    }
}

void ProcessControllerActionMethods(ControllerInfo controllerInfo, CodeClass2 current) {

    // We want to process not just the controller class itself, but also its parents, as they
    // may themselves define actions
    for (CodeClass2 type = current; type != null && type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2)type.Bases.Item(1)) {

        // If the type doesn't come from this project, some actions on it will fail. Try to get a real project type if possible.
        if (type.InfoLocation != vsCMInfoLocation.vsCMInfoLocationProject) {
            
            for (int i = 1; i <= Dte.Solution.Projects.Count; i++) {
                Project prj = null;
                try {
                    prj = Dte.Solution.Projects.Item(i);
                }
                catch (System.Runtime.Serialization.SerializationException) {
                    // Some project types (that we don't care about) cause a strange exception, so ingore it
                    continue;
                }

                // Skip it if it's the current project or doesn't have a code model
                try {
                   if (prj == Project || prj.CodeModel == null)
                      continue;
                }
                catch (System.NotImplementedException) {
                   // Installer project does not implement CodeModel property
                   continue;
                }

                // If we can get a local project type, use it instead of the original
                var codeType = prj.CodeModel.CodeTypeFromFullName(type.FullName);
                if (codeType != null && codeType.InfoLocation == vsCMInfoLocation.vsCMInfoLocationProject) {
                    type = (CodeClass2)codeType;
                    break;
                }
            }
        }

        foreach (CodeFunction2 method in GetMethods(type)) {
			
			CodeAttribute2 ajaxAttribute = null;

			try{
				ajaxAttribute = GetAttribute(method.Attributes, AttributeNamespace + ".AjaxEndpointAttribute");
				if (ajaxAttribute == null){
					continue;
				}
			}
			catch(System.Runtime.InteropServices.COMException){
				break;
			}


            // Ignore non-public methods
            if (method.Access != vsCMAccess.vsCMAccessPublic)
                continue;

            // Ignore methods that are marked as not being actions
            if (GetAttribute(method.Attributes, "System.Web.Mvc.NonActionAttribute") != null)
                continue;

            // This takes care of avoiding generic types which cause method.Type.CodeType to blow up
            if (method.Type.TypeKind != vsCMTypeRef.vsCMTypeRefCodeType)
                continue;

            // We only support action methods that return an ActionResult derived type
            if (!method.Type.CodeType.get_IsDerivedFrom("System.Web.Mvc.ActionResult")) {
                Warning(String.Format("{0} doesn't support {1}.{2} because it doesn't return a supported ActionResult type", T4FileName, type.Name, method.Name));
                continue;
            }


			if(ajaxAttribute.Arguments.Count > 0)
			{
				List<string> parameters = new List<string>();

				foreach(CodeAttributeArgument arg in ajaxAttribute.Arguments){
					parameters.Add(arg.Value);
				}

				controllerInfo.ActionMethods.Add(new ActionMethodInfo(parameters,method));
			}
			else{
				// Collect misc info about the action method and add it to the collection
				controllerInfo.ActionMethods.Add(new ActionMethodInfo(method));
			}
        }
    }
}

ProjectItem GetProjectItem(Project project, string name) {
    return GetProjectItem(project.ProjectItems, name);
}

ProjectItem GetProjectItem(ProjectItems items, string subPath) {

    ProjectItem current = null;
    foreach (string name in subPath.Split('\\')) {
        try {
            // ProjectItems.Item() throws when it doesn't exist, so catch the exception
            // to return null instead.
            current = items.Item(name);
        }
        catch {
            // If any chunk couldn't be found, fail
            return null;
        }
        items = current.ProjectItems;
    }

    return current;
}

static string ProcessAreaOrControllerName(string name) {
    return name.ToLowerInvariant();
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass) {
    // Only look at regular method (e.g. ignore things like contructors)
    return codeClass.Members.OfType<CodeFunction2>()
        .Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionFunction);
}

// Find a method with a given name
static CodeFunction2 GetMethod(CodeClass2 codeClass, string name) {
    return GetMethods(codeClass).FirstOrDefault(f => f.Name == name);
}

// Find an attribute of a given type on an attribute collection
static CodeAttribute2 GetAttribute(CodeElements attributes, string attributeType) {
    for (int i = 1; i <= attributes.Count; i++) {
        var attrib = (CodeAttribute2)attributes.Item(i);
			
		if (attrib.FullName == attributeType) {
			return attrib;
		}
    }
    return null;
}

// Return whether a ProjectItem is a folder and not a file
static bool IsFolder(ProjectItem item) {
    return (item.Kind == Constants.vsProjectItemKindPhysicalFolder);
}

static string MakeClassName(string ns, string classname) {
    return String.IsNullOrEmpty(ns) ? classname :
        String.IsNullOrEmpty(classname) ? ns : ns + "." + codeProvider.CreateEscapedIdentifier(classname);
}


// Data structure to collect data about an area
class AreaInfo {
    public AreaInfo() {
        Controllers = new HashSet<ControllerInfo>();
    }

    public string Name { get; set; }
    public HashSet<ControllerInfo> Controllers { get; set; }

    public string Namespace {
        get {
            // When *not* using an 'Areas' token, we need to disambiguate conflicts
            // between Area names and controller names (from the default Area)
            if (/*!IncludeAreasToken && */DefaultArea.Controllers.Any(c => c.Name == Name))
                return Name + "Area";

            return Name;
        }
    }

    public IEnumerable<ControllerInfo> GetControllers() {
        return Controllers.Where(c => !c.IsAbstract);
    }
}

// Data structure to collect data about a controller class
class ControllerInfo {
    public ControllerInfo() {
        ActionMethods = new HashSet<ActionMethodInfo>();
    }

    public AreaInfo Area { get; set; }

    public string AreaName {
        get { return Area.Name ?? ""; }
    }

    public bool IsAbstract { get; set; }

    public bool GeneratedCodeIsUpToDate { get; set; }

    public string ClassName { get; set; }
    public string Name {
        get {
            // Trim the Controller suffix
            return ClassName.Substring(0, ClassName.Length - ControllerSuffix.Length);
        }
    }

    public string Namespace { get; set; }

    public string FullClassName {
        get {
            return MakeClassName(Namespace, ClassName);
        }
    }
		
    public string GeneratedFileName {
        get {
            return MakeClassName(AreaName, ClassName + ".generated.js");
        }
    }

    public string GeneratedFileFullPath {
        get {
            return Path.Combine(T4Folder, GeneratedFileName);
        }
    }

    public HashSet<ActionMethodInfo> ActionMethods { get; set; }

    // Return a list of actions without duplicate names (even with multiple overloads)
    public IEnumerable<ActionMethodInfo> ActionMethodsWithUniqueNames {
        get {
            return ActionMethods.Distinct(new ActionComparer());
        }
    }

    class ActionComparer : IEqualityComparer<ActionMethodInfo> {
        public bool Equals(ActionMethodInfo x, ActionMethodInfo y) {
            return x.ActionName == y.ActionName;
        }

        public int GetHashCode(ActionMethodInfo obj) {
            return obj.ActionName.GetHashCode();
        }
    }
	
    public override string ToString() {
        return Name;
    }

    public override bool Equals(object obj) {
        return obj != null && FullClassName == ((ControllerInfo)obj).FullClassName;
    }

    public override int GetHashCode() {
        return FullClassName.GetHashCode();
    }
}


// Data structure to collect data about a method
class FunctionInfo {
    protected CodeFunction2 _method;
    protected string _signature;

    public FunctionInfo(CodeFunction2 method) {
        Parameters = new List<MethodParamInfo>();

        // Can be null when an custom ActionResult has no ctor
        if (method == null)
            return;

        _method = method;

        // Build a unique signature for the method, used to avoid duplication
        _signature = method.Name;

        CanBeCalledWithoutParameters = true;

        // Process all the parameters
        foreach (var p in method.Parameters.OfType<CodeParameter2>()) {
            // If any param is not optional, then the method can't be called without parameters
            if (p.ParameterKind != vsCMParameterKind.vsCMParameterKindOptional) {
                CanBeCalledWithoutParameters = false;
            }

            string routeNameExpression = "\"" + p.Name + "\"";

            // If there is a [Bind(Prefix = "someName")] attribute, use it
            if (p.InfoLocation != vsCMInfoLocation.vsCMInfoLocationExternal) {
                var attrib = GetAttribute(p.Attributes, "System.Web.Mvc.BindAttribute");
                if (attrib != null) {
                    var arg = attrib.Arguments.OfType<CodeAttributeArgument>().FirstOrDefault(a => a.Name == "Prefix");
                    if (arg != null)
                        routeNameExpression = arg.Value;
                }
            }
			
			Parameters.Add(
				new MethodParamInfo() {
					Name = p.Name,
					RouteNameExpression = routeNameExpression,
					Type = p.Type.AsString
				});
			_signature += "," + p.Type.AsString;
        }
    }

    public string Name { get { return _method.Name; } }
    public List<MethodParamInfo> Parameters { get; private set; }
    public bool CanBeCalledWithoutParameters { get; private set; }
	
    public override bool Equals(object obj) {
        return obj != null && _signature == ((FunctionInfo)obj)._signature;
    }

    public override int GetHashCode() {
        return _signature.GetHashCode();
    }
}

// Data structure to collect data about an action method
class ActionMethodInfo : FunctionInfo {
    public ActionMethodInfo(CodeFunction2 method) : base(method) {
        // Normally, the action name is the method name. But if there is an [ActionName] on
        // the method, get the expression from that instead
        ActionNameValueExpression = '"' + Name + '"';
        var attrib = GetAttribute(method.Attributes, "System.Web.Mvc.ActionNameAttribute");
        if (attrib != null) {
            var arg = (CodeAttributeArgument)attrib.Arguments.Item(1);
            ActionNameValueExpression = arg.Value;
        }

		Verb = "GET";

		var varbAttribute = GetAttribute(method.Attributes, "System.Web.Mvc.HttpPostAttribute");
        if (varbAttribute != null) {
            Verb = "POST";
        }
    }

	public ActionMethodInfo(List<string> parameters, CodeFunction2 method) : this(method) {
		Parameters.Clear();
		_signature = "";
		
		foreach(var p in parameters)
		{
			Parameters.Add(new MethodParamInfo() {
					Name = p,
					RouteNameExpression = p,
					Type = ""
				});
			_signature += "," + p;
		}
	}

	public string Verb{ get; set; }
    public string ActionName { get { return Name; } }
    public string ActionNameValueExpression { get; set; }
}

// Data about an ActionResult derived type
class ResultTypeInfo {
    CodeType _codeType;
    public ResultTypeInfo(CodeType codeType) {
        _codeType = codeType;

        //var ctor = _codeType.Members.OfType<CodeFunction2>().FirstOrDefault(
        //    f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
        //Constructor = new FunctionInfo(ctor);
    }

    public string Name { get { return _codeType.Name; } }
    public string FullName { get { return _codeType.FullName; } }
    //public FunctionInfo Constructor { get; set; }
    public IEnumerable<FunctionInfo> AbstractMethods {
        get {
            return _codeType.Members.OfType<CodeFunction2>().Where(
                f => f.MustImplement).Select(f => new FunctionInfo(f));
        }
    }
}

class MethodParamInfo {
    public string Name { get; set; }
    public string RouteNameExpression { get; set; }
    public string Type { get; set; }
}


/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void KeepGeneratedFile(String name) {
        name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
        generatedFileNames.Add(name);
    }
    
    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

	public virtual void RelocateScriptFile(string fileName){
		
	}

    public virtual void Process(bool split) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();

            foreach (Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }
	
    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

		public override void RelocateScriptFile(string fileName){
			var templateFileName = Path.GetFileName(host.TemplateFile);
			var targetFilename = Path.GetFileName(fileName);
			var sourceFile = host.TemplateFile.Replace(templateFileName, targetFilename);
			
			var content = File.ReadAllText(sourceFile);
			
			var scriptFilePath = Path.Combine(host.TemplateFile.Replace(templateFileName, ""), fileName);

			try{
				if(!File.Exists(scriptFilePath)){
					CreateFile(scriptFilePath, content);
					try{
						EnvDTE.ProjectItem jsfile = Project.ProjectItems.AddFromFile(scriptFilePath);
					}
					catch{}
				}

				CreateFile(scriptFilePath, content);
			}
			catch(System.IO.DirectoryNotFoundException){
				throw new System.IO.DirectoryNotFoundException("\r\n\r\nPlease edit the T4JS.settings.t4 file by updating the ScriptFileName setting with the path to the folder containing our script files.\r\n\r\n");
			}
		}

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        public static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems){
			    projectFiles.Add(projectItem.get_FileNames(0), projectItem);
			}

            // Remove unused items from the project
            foreach (var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach (String fileName in keepFileNameSet){
				
                if (!projectFiles.ContainsKey(fileName)){

					if(!File.Exists(fileName)){
						File.WriteAllText(fileName, "");
					}

                    templateProjectItem.ProjectItems.AddFromFile(fileName);
				}
			}
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}

/*
    End of Manager.tt
*/
#>
